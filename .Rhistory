# }
#data <- x$get()
#inverseM <- solve(data)
#x$setinverse(inverseM)
#inverseM
}
makeCacheMatrix <- matrix(1:4,2,2)
z<- cacheSolve(makeCacheMatrix)
class(z)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## This function will create an object matrix which will have the matrix
## and the inverse of it stored in cache
makeCacheMatrix <- function(x = matrix()) {
invM <- NULL
set <- function(x){
matrix <<- x
invM <<- NULL
}
get <- function() x
setinverse <- function(inverse) invM <<- inverse
getinverse <- function() invM
list(set = set,get = get,setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
## This function will find out if there is any cache of inverse matrix
## If not then it will find the inverse of the matrix and will store it
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverseM <- x$getinverse
# if(!is.NULL(inverseM)){
# return(inverseM)
# }
#data <- x$get()
#inverseM <- solve(data)
#x$setinverse(inverseM)
#inverseM
}
makeCacheMatrix <- matrix(1:4,2,2)
z<- cacheSolve(makeCacheMatrix)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## This function will create an object matrix which will have the matrix
## and the inverse of it stored in cache
makeCacheMatrix <- function(x = matrix()) {
invM <- NULL
set <- function(x){
matrix <<- x
invM <<- NULL
}
get <- function() x
setinverse <- function(inverse) invM <<- inverse
getinverse <- function() invM
list(set = set,get = get,setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
## This function will find out if there is any cache of inverse matrix
## If not then it will find the inverse of the matrix and will store it
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverseM <- x["getinverse"]
# if(!is.NULL(inverseM)){
# return(inverseM)
# }
#data <- x$get()
#inverseM <- solve(data)
#x$setinverse(inverseM)
#inverseM
}
makeCacheMatrix <- matrix(1:4,2,2)
z<- cacheSolve(makeCacheMatrix)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## This function will create an object matrix which will have the matrix
## and the inverse of it stored in cache
makeCacheMatrix <- function(x = matrix()) {
invM <- NULL
set <- function(x){
matrix <<- x
invM <<- NULL
}
get <- function() x
setinverse <- function(inverse) invM <<- inverse
getinverse <- function() invM
list(set = set,get = get,setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
## This function will find out if there is any cache of inverse matrix
## If not then it will find the inverse of the matrix and will store it
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverseM <- x["getinverse"]
if(!is.NULL(inverseM)){
return(inverseM)
}
data <- x$get()
inverseM <- solve(data)
x$setinverse(inverseM)
inverseM
}
makeCacheMatrix <- matrix(1:4,2,2)
z<- cacheSolve(makeCacheMatrix)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## This function will create an object matrix which will have the matrix
## and the inverse of it stored in cache
makeCacheMatrix <- function(x = matrix()) {
invM <- NULL
set <- function(x){
matrix <<- x
invM <<- NULL
}
get <- function() x
setinverse <- function(inverse) invM <<- inverse
getinverse <- function() invM
list(set = set,get = get,setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
## This function will find out if there is any cache of inverse matrix
## If not then it will find the inverse of the matrix and will store it
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverseM <- x["getinverse"]
if(!is.null(inverseM)){
return(inverseM)
}
data <- x$get()
inverseM <- solve(data)
x$setinverse(inverseM)
inverseM
}
makeCacheMatrix <- matrix(1:4,2,2)
z<- cacheSolve(makeCacheMatrix)
z
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## This function will create an object matrix which will have the matrix
## and the inverse of it stored in cache
makeCacheMatrix <- function(x = matrix()) {
invM <- NULL
set <- function(x){
matrix <<- x
invM <<- NULL
}
get <- function() x
setinverse <- function(inverse) invM <<- inverse
getinverse <- function() invM
list(set = set,get = get,setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
## This function will find out if there is any cache of inverse matrix
## If not then it will find the inverse of the matrix and will store it
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverseM <- x["getinverse"]
if(!is.null(inverseM)){
print("Here i am")
return(inverseM)
}
data <- x$get()
inverseM <- solve(data)
x$setinverse(inverseM)
inverseM
}
makeCacheMatrix <- matrix(1:4,2,2)
cacheSolve(makeCacheMatrix)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## This function will create an object matrix which will have the matrix
## and the inverse of it stored in cache
makeCacheMatrix <- function(x = matrix()) {
invM <- NULL
set <- function(x){
matrix <<- x
invM <<- NULL
}
get <- function() x
setinverse <- function(inverse) invM <<- inverse
getinverse <- function() invM
list(set = set,get = get,setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
## This function will find out if there is any cache of inverse matrix
## If not then it will find the inverse of the matrix and will store it
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverseM <- x["getinverse"]
if(!is.na(inverseM)){
print("Here i am")
return(inverseM)
}
data <- x$get()
inverseM <- solve(data)
x$setinverse(inverseM)
inverseM
}
makeCacheMatrix <- matrix(1:4,2,2)
cacheSolve(makeCacheMatrix)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## This function will create an object matrix which will have the matrix
## and the inverse of it stored in cache
makeCacheMatrix <- function(x = matrix()) {
invM <- NULL
set <- function(x){
matrix <<- x
invM <<- NULL
}
get <- function() x
setinverse <- function(inverse) invM <<- inverse
getinverse <- function() invM
list(set = set,get = get,setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
## This function will find out if there is any cache of inverse matrix
## If not then it will find the inverse of the matrix and will store it
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverseM <- x["getinverse"]
if(!is.na(inverseM)){
print("Here i am")
return(inverseM)
}
data <- x["get"]
inverseM <- solve(data)
x$setinverse(inverseM)
inverseM
}
makeCacheMatrix <- matrix(1:4,2,2)
cacheSolve(makeCacheMatrix)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## This function will create an object matrix which will have the matrix
## and the inverse of it stored in cache
makeCacheMatrix <- function(x = matrix()) {
invM <- NULL
set <- function(x){
matrix <<- x
invM <<- NULL
}
get <- function() x
setinverse <- function(inverse) invM <<- inverse
getinverse <- function() invM
list(set = set,get = get,setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
## This function will find out if there is any cache of inverse matrix
## If not then it will find the inverse of the matrix and will store it
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverseM <- x["getinverse"]
if(!is.na(inverseM)){
print("Here i am")
return(inverseM)
}
data <- x["get"]
inverseM <- solve(data)
x["setinverse"] <- inverseM
inverseM
}
makeCacheMatrix <- matrix(1:4,2,2)
cacheSolve(makeCacheMatrix)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## This function will create an object matrix which will have the matrix
## and the inverse of it stored in cache
makeCacheMatrix <- function(x = matrix()) {
invM <- NULL
set <- function(x){
matrix <<- x
invM <<- NULL
}
get <- function() x
setinverse <- function(inverse) invM <<- inverse
getinverse <- function() invM
list(set = set,get = get,setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
## This function will find out if there is any cache of inverse matrix
## If not then it will find the inverse of the matrix and will store it
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverseM <- x["getinverse"]
if(!is.na(inverseM)){
print("Here i am")
return(inverseM)
}
data <- x["get"]
data
#inverseM <- solve(data)
# x["setinverse"] <- inverseM
#  inverseM
}
makeCacheMatrix <- matrix(1:4,2,2)
cacheSolve(makeCacheMatrix)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
makeVector(x = 1:3)
cachemean(makeVector)
cachemean(1:3)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## This function will create an object matrix which will have the matrix
## and the inverse of it stored in cache
makeCacheMatrix <- function(x = matrix()) {
invM <- NULL
set <- function(x){
matrix <<- x
invM <<- NULL
}
get <- function() x
setinverse <- function(inverse) invM <<- inverse
getinverse <- function() invM
list(set = set,get = get,setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
## This function will find out if there is any cache of inverse matrix
## If not then it will find the inverse of the matrix and will store it
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverseM <- x["getinverse"]
if(!is.na(inverseM)){
print("Here i am")
return(inverseM)
}
data <- x["get"]
data
#inverseM <- solve(data)
# x["setinverse"] <- inverseM
#  inverseM
}
makeCacheMatrix <- matrix(1:4,2,2)
cacheSolve(1:4)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## This function will create an object matrix which will have the matrix
## and the inverse of it stored in cache
makeCacheMatrix <- function(x = matrix()) {
inverseM <- NULL
setM <- function(y) {
x <<- y
inverseM <<- NULL
}
getM <- function() x
setInverseM <- function(inverse) inverseM <<- inverse
getInverseM <- function() inverseM
list(set = setM, get = getM, setInv = setInverseM,getInv = getInverseM)
}
## Write a short comment describing this function
## This function will find out if there is any cache of inverse matrix
## If not then it will find the inverse of the matrix and will store it
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverseM <- x$getInverse()
if(!is.null(inverseM)){
print("Inverse of the matrix is cached")
return(inverseM)
}
data <- x$getM()
inverseM <- solve(data,...)
x$setInv(inverseM)
inverseM
}
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$get()
my_matrix$getInv()
cacheSolve(my_matrix)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## This function will create an object matrix which will have the matrix
## and the inverse of it stored in cache
makeCacheMatrix <- function(x = matrix()) {
inverseM <- NULL
setM <- function(y) {
x <<- y
inverseM <<- NULL
}
getM <- function() x
setInverseM <- function(inverse) inverseM <<- inverse
getInverseM <- function() inverseM
list(set = setM, get = getM, setInv = setInverseM,getInv = getInverseM)
}
## Write a short comment describing this function
## This function will find out if there is any cache of inverse matrix
## If not then it will find the inverse of the matrix and will store it
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverseM <- x$getInv()
if(!is.null(inverseM)){
print("Inverse of the matrix is cached")
return(inverseM)
}
data <- x$getM()
inverseM <- solve(data,...)
x$setInv(inverseM)
inverseM
}
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## This function will create an object matrix which will have the matrix
## and the inverse of it stored in cache
makeCacheMatrix <- function(x = matrix()) {
inverseM <- NULL
setM <- function(y) {
x <<- y
inverseM <<- NULL
}
getM <- function() x
setInverseM <- function(inverse) inverseM <<- inverse
getInverseM <- function() inverseM
list(set = setM, get = getM, setInv = setInverseM,getInv = getInverseM)
}
## Write a short comment describing this function
## This function will find out if there is any cache of inverse matrix
## If not then it will find the inverse of the matrix and will store it
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverseM <- x$getInv()
if(!is.null(inverseM)){
print("Inverse of the matrix is cached")
return(inverseM)
}
data <- x$getM()
inverseM <- solve(data,...)
x$setInv(inverseM)
inverseM
}
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$get()
my_matrix$getInv()
cacheSolve(my_matrix)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## This function will create an object matrix which will have the matrix
## and the inverse of it stored in cache
makeCacheMatrix <- function(x = matrix()) {
inverseM <- NULL
setM <- function(y) {
x <<- y
inverseM <<- NULL
}
getM <- function() x
setInverseM <- function(inverse) inverseM <<- inverse
getInverseM <- function() inverseM
list(set = setM, get = getM, setInv = setInverseM,getInv = getInverseM)
}
## Write a short comment describing this function
## This function will find out if there is any cache of inverse matrix
## If not then it will find the inverse of the matrix and will store it
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverseM <- x$getInv()
if(!is.null(inverseM)){
print("Inverse of the matrix is cached")
return(inverseM)
}
data <- x$get()
inverseM <- solve(data,...)
x$setInv(inverseM)
inverseM
}
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$get()
my_matrix$getInv()
cacheSolve(my_matrix)
my_matrix$getInv()
